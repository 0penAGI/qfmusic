<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <style>
    body {
      margin: 0;
      padding: 0;
      background: #050505;
      color: #f0f0f0;
      font-family: system-ui, -apple-system, monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
      overflow: hidden;
    }

    #container {
      position: relative;
      z-index: 10;
      background: rgba(15, 15, 15, 0.6);
      backdrop-filter: blur(12px) saturate(120%);
      -webkit-backdrop-filter: blur(12px) saturate(120%);
      border: none;
      padding: 42px 56px;
      min-width: 340px;
      text-align: center;
      box-shadow: 0 0 40px rgba(0, 0, 0, 0.8);
      transition: opacity 1.5s ease;
      pointer-events: auto;
      touch-action: manipulation;
    }

    h1 {
      font-size: 1.3em;
      margin-bottom: 1.6em;
      letter-spacing: 0.18em;
      text-transform: uppercase;
      color: #ffffff;
      text-shadow: none;
    }

    button {
      background: rgba(255, 255, 255, 0.03);
      border: none;
      color: #e6e6e6;
      padding: 12px 26px;
      margin: 8px;
      font-size: 0.9em;
      cursor: pointer;
      font-family: inherit;
      letter-spacing: 0.08em;
      transition: background 0.2s, border 0.2s, color 0.2s;
    }

    button:hover {
      background: rgba(255, 255, 255, 0.08);
      border-color: transparent;
      color: #ffffff;
      box-shadow: none;
    }

    button:active {
      background: rgba(255, 255, 255, 0.02);
    }

    #status {
      margin-top: 1.6em;
      font-size: 0.85em;
      letter-spacing: 0.06em;
      color: #b0b0b0;
      text-shadow: none;
    }

    #info {
      margin-top: 0.7em;
      font-size: 0.75em;
      color: #7a7a7a;
      opacity: 1;
    }

    canvas {
      position: fixed;
      top: 0;
      left: 0;
      z-index: 1;
      pointer-events: auto;
      filter: grayscale(1) contrast(1.1) brightness(1.2);
    }

    @media (max-width: 768px) {
      #container {
        padding: 28px 24px;
        min-width: auto;
        width: 85vw;
      }

      h1 {
        font-size: 1em;
      }

      button {
        width: 100%;
        margin: 6px 0;
      }
    }
  </style>
</head>
<body>
  <canvas id="visual"></canvas>
  <div id="container">
    <h1>qf music / turn off silence mode to listen</h1>
    <div>
      <button id="startBtn">коллапс</button>
      <button id="stopBtn">стабилизация</button>
      <button id="regenBtn">перерождение</button>
    </div>
    <div id="status">ожидание</div>
    <div id="info"></div>
  </div>
  <script>
    let generator = null;

    window.__audioEnergy = 0.2;
    window.__visualEnergy = 0.0;
    window.__smoothedEnergy = 0.2;

    const feedbackBuffer = new Uint8Array(4);

    function sampleVisualEnergy() {
      gl.readPixels(
        canvas.width / 2,
        canvas.height / 2,
        1,
        1,
        gl.RGBA,
        gl.UNSIGNED_BYTE,
        feedbackBuffer
      );

      const v =
        (feedbackBuffer[0] +
         feedbackBuffer[1] +
         feedbackBuffer[2]) / (3 * 255);

      window.__visualEnergy =
        window.__visualEnergy * 0.9 + v * 0.1;
    }
    
    let uiHidden = false;

    function hideUI() {
      const ui = document.getElementById('container');
      if (!ui) return;

      ui.style.transition = 'opacity 1.5s ease';
      ui.style.opacity = '0';
      ui.style.pointerEvents = 'none';
      uiHidden = true;
    }

    function showUI() {
      const ui = document.getElementById('container');
      if (!ui) return;

      ui.style.transition = 'opacity 0.6s ease';
      ui.style.opacity = '1';
      ui.style.pointerEvents = 'auto';
      uiHidden = false;
    }

    setTimeout(hideUI, 15000);

    // Визуализация
    const canvas = document.getElementById('visual');
    const gl = canvas.getContext('webgl');

    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    gl.viewport(0, 0, canvas.width, canvas.height);

    const vertexSrc = `
    attribute vec2 position;
    void main() {
      gl_Position = vec4(position, 0.0, 1.0);
    }`;

    const fragmentSrc = `
precision highp float;

uniform float time;
uniform float energy;
uniform vec2 resolution;

float hash(vec2 p){
  return fract(sin(dot(p,vec2(41.7,113.5)))*43758.5453);
}

vec2 attract(vec2 p, vec2 c, float s){
  vec2 d = c - p;
  float r = length(d)+0.001;
  return d / r * s / (r*r);
}

float noise(vec2 p){
  return hash(floor(p)) * 0.5 + hash(floor(p*2.0))*0.25;
}

void main(){

  vec2 uv = gl_FragCoord.xy / resolution.xy;
  vec2 p = uv*2.0-1.0;
  p.x *= resolution.x/resolution.y;

  float t = time*0.25;
  float e = clamp(energy,0.05,1.5);

  vec2 a1 = vec2(sin(t*0.7),cos(t*0.9))*0.6;
  vec2 a2 = vec2(cos(t*1.1),sin(t*0.6))*0.5;
  vec2 a3 = vec2(sin(t*0.4+2.0),cos(t*0.5))*0.7;

  vec2 v = vec2(0.0);

  v += attract(p,a1,0.8*e);
  v += attract(p,a2,0.6*e);
  v += attract(p,a3,0.7*e);

  v += vec2(
    noise(p*6.0+t),
    noise(p*6.0-t)
  )*0.15;

  p += v*0.25;

  float d1 = length(p-a1);
  float d2 = length(p-a2);
  float d3 = length(p-a3);

  float ink =
    exp(-d1*6.0)+
    exp(-d2*5.0)+
    exp(-d3*7.0);

  float grain = noise(p*12.0+t)*0.15;

  float paint = smoothstep(0.02,0.9,ink+grain);

  paint = pow(paint, 0.75);
  paint *= 1.1 + e*2.4;
  paint = clamp(paint * 1.8, 0.0, 1.0);

  gl_FragColor = vec4(vec3(paint),0.18);
}
`;

    function compile(type, src) {
      const s = gl.createShader(type);
      gl.shaderSource(s, src);
      gl.compileShader(s);
      return s;
    }

    const vs = compile(gl.VERTEX_SHADER, vertexSrc);
    const fs = compile(gl.FRAGMENT_SHADER, fragmentSrc);

    const program = gl.createProgram();
    gl.attachShader(program, vs);
    gl.attachShader(program, fs);
    gl.linkProgram(program);
    gl.useProgram(program);

    const buffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);

    gl.bufferData(
      gl.ARRAY_BUFFER,
      new Float32Array([
        -1, -1,
         1, -1,
        -1,  1,
         1,  1
      ]),
      gl.STATIC_DRAW
    );

    const pos = gl.getAttribLocation(program, 'position');
    gl.enableVertexAttribArray(pos);
    gl.vertexAttribPointer(pos, 2, gl.FLOAT, false, 0, 0);

    const uTime = gl.getUniformLocation(program, 'time');
    const uEnergy = gl.getUniformLocation(program, 'energy');
    const uRes = gl.getUniformLocation(program, 'resolution');

    function render(now) {
      const t = now * 0.001;
      window.__smoothedEnergy =
        window.__smoothedEnergy * 0.92 +
        (window.__audioEnergy || 0.2) * 0.08;

      const energy = window.__smoothedEnergy;

      gl.uniform1f(uTime, t);
      gl.uniform1f(uEnergy, energy);
      gl.uniform2f(uRes, canvas.width, canvas.height);

      gl.enable(gl.BLEND);
      gl.lineWidth(1.0);
      gl.blendFunc(gl.SRC_ALPHA, gl.ONE);

      gl.clearColor(0.0,0.0,0.0,0.045);
      gl.clear(gl.COLOR_BUFFER_BIT);

      gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

      sampleVisualEnergy();

      requestAnimationFrame(render);
    }

    requestAnimationFrame(render);

    // Генератор музыки
    class QuantumNode {
      constructor(freq, depth, parent = null) {
        this.freq = freq;
        this.depth = depth;
        this.parent = parent;
        this.entangled = new Set();
        this.phase = Math.random() * Math.PI * 2;
        this.alive = true;
      }
      
      entangle(other) {
        this.entangled.add(other);
        other.entangled.add(this);
      }
      
      collapse() {
        const resonance = Math.sin(this.phase);
        this.entangled.forEach(node => {
          if (node.alive) {
            node.phase = this.phase + Math.PI * resonance;
          }
        });
        return resonance;
      }
    }

    class FractalMusicGenerator {
      constructor() {
        this.audioContext = null;
        this.nodes = [];
        this.baseFreq = 432;
        this.maxDepth = 5;
        this.isPlaying = false;
        this.time = 0;
        this.memory = [];
        this.maxMemory = 64; // smaller memory = faster forgetting
        this.energy = 1.0;

        this.activeVoices = new Set(); // track playing sounds
        this.maxVoices = 12; // softer polyphony = less harshness
        this.bufferCache = new Map();
        this.maxCacheSize = 20;
        this.masterCompressor = null;
        this.initQuantumField();
      }
      
      initQuantumField() {
        const root = new QuantumNode(this.baseFreq, 0);
        this.nodes.push(root);
        
        this.growFractal(root, 0);
        
        for (let i = 0; i < this.nodes.length; i++) {
          const node = this.nodes[i];
          const goldenRatio = 1.618033988749;
          const targetFreq = node.freq * Math.pow(goldenRatio, node.depth % 3);
          
          const partner = this.nodes.find(n => 
            Math.abs(n.freq - targetFreq) < 50 && n !== node
          );
          
          if (partner) {
            node.entangle(partner);
          }
        }
      }
      
      growFractal(parent, depth) {
        if (depth >= this.maxDepth) return;
        
        const ratios = [1.5, 1.333, 1.618, 2, 0.666];
        
        ratios.forEach((ratio, i) => {
          if (Math.random() > 0.3 || depth === 0) {
            const child = new QuantumNode(
              parent.freq * ratio,
              depth + 1,
              parent
            );
            this.nodes.push(child);
            
            if (Math.random() > 0.5) {
              parent.entangle(child);
            }
            
            this.growFractal(child, depth + 1);
          }
        });
      }
      
      getNoiseBuffer(ctx) {
        const key = `noise_${Math.floor(this.time / 10000)}`;

        if (this.bufferCache.has(key)) {
          return this.bufferCache.get(key);
        }

        const grainSize = 0.05 + Math.random() * 0.1;
        const buffer = ctx.createBuffer(1, ctx.sampleRate * grainSize, ctx.sampleRate);
        const data = buffer.getChannelData(0);

        for (let i = 0; i < data.length; i++) {
          const t = i / data.length;
          const env = Math.sin(Math.PI * t);
          const white = Math.random() * 2 - 1;
          const prev = i > 0 ? data[i - 1] : 0;
          const brown = (prev + white * 0.02) / 1.02;
          data[i] = (white * 0.6 + brown * 0.4) * env * 0.15;
        }

        this.bufferCache.set(key, buffer);

        if (this.bufferCache.size > this.maxCacheSize) {
          const firstKey = this.bufferCache.keys().next().value;
          this.bufferCache.delete(firstKey);
        }

        return buffer;
      }

      createOscillator(freq, duration, startTime) {
        if (!this.audioContext) return;
        
        if (this.activeVoices.size > this.maxVoices) {
          // kill oldest voice
          const old = this.activeVoices.values().next().value;
          if (old) {
            try { old.stop(); } catch(e){}
            this.activeVoices.delete(old);
          }
        }
        const osc = this.audioContext.createOscillator();
        const gain = this.audioContext.createGain();

        // --- 4D auto-pan + phase motion ---
        const panner = ctx.createStereoPanner();
        panner.pan.value = (Math.random() * 2 - 1) * 0.5;

        const panLFO = ctx.createOscillator();
        const panLFOGain = ctx.createGain();

        panLFO.type = 'sine';
        panLFO.frequency.value = 0.02 + Math.random() * 0.12; // slow orbital motion
        panLFOGain.gain.value = 0.4 + Math.random() * 0.3;

        panLFO.connect(panLFOGain);
        panLFOGain.connect(panner.pan);
        panLFO.start();

        // --- spectral panorama EQ ---
        const spatialEQ = ctx.createBiquadFilter();
        spatialEQ.type = 'peaking';
        spatialEQ.frequency.value = 800 + Math.random() * 1800;
        spatialEQ.Q.value = 0.6 + Math.random() * 1.2;
        spatialEQ.gain.value = (Math.random() - 0.5) * 6;

        const ctx = this.audioContext;

        const visual = window.__visualEnergy || 0.0;

        const micro = (Math.random() - 0.5) * 15 * visual;
        const tempered = freq * Math.pow(2, micro / 1200);

        // waveform selection + detune
        const waveforms = ['sine','triangle','sawtooth','square'];
        osc.type = waveforms[Math.floor(Math.random() * waveforms.length)];

        // random detune for texture
        osc.detune.value = (Math.random()-0.5) * 25;
        osc.frequency.value = tempered;

        const sub = ctx.createOscillator();
        sub.type = 'sine';
        sub.frequency.value = tempered * 0.5;

        const subGain = ctx.createGain();
        subGain.gain.value = 0.08 + visual * 0.2;

        const overtone = ctx.createOscillator();
        overtone.type = 'sine';
        overtone.frequency.value = tempered * (0.6 + visual * 0.5);

        const overtoneGain = ctx.createGain();
        overtoneGain.gain.value = 0.03 + Math.random()*0.06 * (1.0 + visual);

        const noise = ctx.createBufferSource();
        noise.buffer = this.getNoiseBuffer(ctx);
        noise.loop = true;

        const grainGain = ctx.createGain();
        grainGain.gain.value = 0.02 + visual * 0.04;

        // --- Articulated ADSR envelope (non-droning) ---
        const amp = 0.16;
        const now = this.audioContext.currentTime;

        // reset gain
        gain.gain.cancelScheduledValues(now);
        gain.gain.setValueAtTime(0.0001, now);

        // ADSR (articulated / non-droning)
        gain.gain.linearRampToValueAtTime(amp, now + 0.04);          // Fast attack
        gain.gain.linearRampToValueAtTime(amp * 0.45, now + 0.18);   // Short decay
        gain.gain.setValueAtTime(amp * 0.4, now + duration * 0.6);   // Low sustain
        gain.gain.linearRampToValueAtTime(0.0001, now + duration);  // Clean release
        // --- END ADSR ---

        osc.connect(gain);
        gain.connect(panner);
        panner.connect(spatialEQ);
        spatialEQ.connect(highCut);

        sub.connect(subGain);
        subGain.connect(gain);

        overtone.connect(overtoneGain);
        overtoneGain.connect(gain);

        noise.connect(grainGain);
        grainGain.connect(gain);

        // distortion / saturation
        const shaper = ctx.createWaveShaper();
        const curve = new Float32Array(256);
        const drive = 1 + Math.random()*4;
        for (let i = 0; i < 256; i++) {
          const x = i * 2 / 255 - 1;
          curve[i] = Math.tanh(x * drive);
        }
        shaper.curve = curve;
        shaper.oversample = '2x';

        // main tone-shaping filter (mostly lowpass)
        const filter = ctx.createBiquadFilter();

        const filterTypes = [
          'lowpass','bandpass','notch'
        ];

        filter.type =
          filterTypes[Math.floor(Math.random()*filterTypes.length)];

        filter.frequency.setValueAtTime(
          600 + Math.random()*1400 + visual*600,
          startTime
        );

        filter.Q.value = 0.6 + Math.random()*3.5;

        const delay = ctx.createDelay();
        delay.delayTime.value = 0.08 + Math.random() * 0.45;

        const tapeFeedback = ctx.createGain();
        tapeFeedback.gain.value = 0.3 + Math.random()*0.4 + visual*0.2;

        const tapeFilter = ctx.createBiquadFilter();
        tapeFilter.type = 'lowpass';
        tapeFilter.frequency.value = 1800;

        const verbDelay = ctx.createDelay();
        verbDelay.delayTime.value = 0.45 + Math.random() * 0.25;

        // --- secondary deep-space reverb ---
        const verbDelay2 = ctx.createDelay();
        verbDelay2.delayTime.value = 0.9 + Math.random() * 0.6;

        const verbFeedback2 = ctx.createGain();
        verbFeedback2.gain.value = 0.4 + Math.random() * 0.25;

        const verbFeedback = ctx.createGain();
        verbFeedback.gain.value = 0.6 + visual * 0.2;

        const wet = ctx.createGain();
        wet.gain.value = 0.45 + visual * 0.25;

        const dry = ctx.createGain();
        dry.gain.value = 0.65;

        // global high-cut safety filter
        const highCut = ctx.createBiquadFilter();
        highCut.type = 'lowpass';
        highCut.frequency.value = 1800;
        highCut.Q.value = 0.7;

        highCut.connect(shaper);
        shaper.connect(filter);

        filter.connect(dry);
        dry.connect(this.masterCompressor || ctx.destination);

        filter.connect(delay);
        delay.connect(tapeFilter);
        tapeFilter.connect(tapeFeedback);
        tapeFeedback.connect(delay);

        delay.connect(wet);

        wet.connect(verbDelay);
        verbDelay.connect(verbFeedback);
        verbFeedback.connect(verbDelay);

        // parallel deep reverb
        wet.connect(verbDelay2);
        verbDelay2.connect(verbFeedback2);
        verbFeedback2.connect(verbDelay2);

        verbDelay.connect(this.masterCompressor || ctx.destination);
        verbDelay2.connect(this.masterCompressor || ctx.destination);

        this.activeVoices.add(osc);
        setTimeout(() => {
          try {
            osc.disconnect();
            gain.disconnect();
            panner.disconnect();
            spatialEQ.disconnect();
            panLFO.disconnect();
            panLFOGain.disconnect();
          } catch(e){}
        }, (duration + 0.5) * 1000);

        osc.onended = () => {
          this.activeVoices.delete(osc);
        };

        // Start oscillators AFTER envelope
        osc.start(startTime);
        const driftAmount = (Math.random() - 0.5) * 8; // ±8 cents
        osc.detune.linearRampToValueAtTime(
          osc.detune.value + driftAmount,
          startTime + duration
        );
        sub.start(startTime);
        overtone.start(startTime);
        noise.start(startTime);

        osc.stop(startTime + duration);
        sub.stop(startTime + duration);
        overtone.stop(startTime + duration);
        noise.stop(startTime + duration);
      }
      
      play() {
        if (this.isPlaying) return;

        if (!this.audioContext) {
          this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
        }

        // mobile unlock pulse
        const osc = this.audioContext.createOscillator();
        const gain = this.audioContext.createGain();
        gain.gain.value = 0.0001;
        osc.connect(gain);
        gain.connect(this.audioContext.destination);
        osc.start();
        osc.stop(this.audioContext.currentTime + 0.02);

        this.audioContext.resume();
        const compressor = this.audioContext.createDynamicsCompressor();
        compressor.threshold.value = -24;
        compressor.knee.value = 12;
        compressor.ratio.value = 3;
        compressor.attack.value = 0.003;
        compressor.release.value = 0.25;
        this.masterCompressor = compressor;
        this.masterCompressor.connect(this.audioContext.destination);
        this.isPlaying = true;

        // small warmup before generate
        setTimeout(() => {
          if (this.isPlaying) {
            this.generate();
          }
        }, 80);
      }
      
      generate() {
        if (!this.isPlaying || !this.audioContext) return;

        const now = this.audioContext.currentTime;
        // probabilistic silence / breathing space
        if (Math.random() < 0.18) {
          const rest = 400 + Math.random() * 900;
          setTimeout(() => this.generate(), rest);
          return;
        }

        let activeNode;
        if (this.memory.length > 0 && Math.random() < 0.6) {
          activeNode = this.memory[Math.floor(Math.random() * this.memory.length)].node;
        } else {
          activeNode = this.nodes[Math.floor(Math.random() * this.nodes.length)];
        }

        if (!activeNode || !activeNode.alive) {
          setTimeout(() => this.generate(), 300);
          return;
        }

        const visual = window.__visualEnergy || 0.0;

        const resonance =
          activeNode.collapse() *
          (1.0 + visual * 1.8);

        const duration = 0.35 + Math.random() * 1.2;
        this.createOscillator(activeNode.freq, duration, now + 0.05);

        let localEnergy = Math.abs(resonance) * 0.6;

        activeNode.entangled.forEach(entangled => {
          if (entangled.alive && Math.random() > 0.3) {
            const harmonic = entangled.freq * (1 + resonance * 0.12);
            this.createOscillator(harmonic, duration * 0.75, now + 0.05);
            localEnergy += 0.5;
          }
        });

        this.memory.push({
          node: activeNode,
          energy: localEnergy,
          time: this.time,
          decay: 1.0
        });

        this.memory = this.memory
          .map(m => {
            m.decay *= 0.9; // exponential forgetting
            return m;
          })
          .filter(m => m.decay > 0.3);

        if (this.memory.length > this.maxMemory) {
          this.memory.length = this.maxMemory;
        }

        this.energy =
          this.energy * 0.9 +
          localEnergy * 0.08 +
          Math.random() * 0.02; // inject chaos
        window.__audioEnergy =
          this.energy * (1.0 + window.__visualEnergy);

        const nextInterval =
          260 +
          Math.random() * 1100 *
          (1.3 - Math.min(this.energy, 1)) +
          (Math.random() < 0.25 ? 600 : 0); // occasional long pause

        setTimeout(() => this.generate(), nextInterval);

        this.time += nextInterval;

        if (this.energy < 0.2 && Math.random() > 0.7) {
          this.mutate();
        } else if (Math.random() > 0.97) {
          this.mutate();
        }
      }
      
      mutate() {
        const aliveNodes = this.nodes.filter(n => n.alive);

        if (aliveNodes.length < 4 || this.nodes.length > 120) return;

        const victim = aliveNodes[Math.floor(Math.random() * aliveNodes.length)];
        victim.alive = false;

        let parent = aliveNodes[0];
        let bestEnergy = -1;

        this.memory.forEach(m => {
          if (m.energy > bestEnergy && m.node.alive) {
            bestEnergy = m.energy;
            parent = m.node;
          }
        });

        const child = new QuantumNode(
          parent.freq * (1 + (Math.random() - 0.5) * 0.3),
          parent.depth + 1,
          parent
        );

        this.nodes.push(child);

        const partner = aliveNodes.find(n =>
          n !== child && Math.random() > 0.4
        );

        if (partner) {
          child.entangle(partner);
        }
      }
      
      stop() {
        this.isPlaying = false;
        this.time = 0;

        // hard cleanup
        this.activeVoices.forEach(v => {
          try { v.stop(); } catch(e){}
        });

        this.activeVoices.clear();

        if (this.audioContext) {
          this.audioContext.suspend().catch(()=>{});
        }
      }
    }

    function init() {
      if (!generator) {
        generator = new FractalMusicGenerator();
      }
      generator.memory = [];
      generator.energy = 1.0;
      document.getElementById('status').textContent = 'система инициализирована';
      document.getElementById('info').textContent = `узлов в поле: ${generator.nodes.length}`;
    }

    // Инициализация при загрузке
    init();

    // Кнопки
    document.getElementById('startBtn').addEventListener('click', function() {
      generator.play();
      showUI();
      setTimeout(hideUI, 4000);
      document.getElementById('status').textContent = 'квантовый коллапс активен';
    });

    document.getElementById('stopBtn').addEventListener('click', function() {
      if (generator) {
        generator.stop();
        document.getElementById('status').textContent = 'волновая функция стабилизирована';
      }
    });

    document.getElementById('regenBtn').addEventListener('click', function() {
      if (generator) {
        generator.stop();
      }
      if (generator && generator.audioContext) {
        generator.audioContext.close().catch(()=>{});
      }
      generator = null;
      init();
    });

    // Касание экрана показывает UI
    canvas.addEventListener('touchstart', showUI);
    canvas.addEventListener('click', showUI);

    window.addEventListener('resize', () => {
      if (!canvas || !gl) return;

      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      gl.viewport(0, 0, canvas.width, canvas.height);
    });
  </script>
</body>
</html>
