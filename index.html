<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <style>
    body {
      margin: 0;
      padding: 0;
      background: #050505;
      color: #f0f0f0;
      font-family: system-ui, -apple-system, monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
      overflow: hidden;
    }

    #container {
      position: relative;
      z-index: 10;
      background: rgba(15, 15, 15, 0.6);
      backdrop-filter: blur(12px) saturate(120%);
      -webkit-backdrop-filter: blur(12px) saturate(120%);
      border: none;
      padding: 42px 56px;
      min-width: 340px;
      text-align: center;
      box-shadow: 0 0 40px rgba(0, 0, 0, 0.8);
      transition: opacity 1.5s ease;
      pointer-events: auto;
      touch-action: manipulation;
    }

    

    h1 {
      font-size: 1.3em;
      margin-bottom: 1.6em;
      letter-spacing: 0.18em;
      text-transform: uppercase;
      color: #ffffff;
      text-shadow: none;
    }

    button {
      background: rgba(255, 255, 255, 0.03);
      border: none;
      color: #e6e6e6;
      padding: 12px 26px;
      margin: 8px;
      font-size: 0.9em;
      cursor: pointer;
      font-family: inherit;
      letter-spacing: 0.08em;
      transition: background 0.2s, border 0.2s, color 0.2s;
    }

    button:hover {
      background: rgba(255, 255, 255, 0.08);
      border-color: transparent;
      color: #ffffff;
      box-shadow: none;
    }

    button:active {
      background: rgba(255, 255, 255, 0.02);
    }

    #status {
      margin-top: 1.6em;
      font-size: 0.85em;
      letter-spacing: 0.06em;
      color: #b0b0b0;
      text-shadow: none;
    }

    #info {
      margin-top: 0.7em;
      font-size: 0.75em;
      color: #7a7a7a;
      opacity: 1;
    }

    canvas {
      position: fixed;
      top: 0;
      left: 0;
      z-index: 1;
      pointer-events: auto;
      filter: grayscale(1) contrast(1.1) brightness(1.2);
    }

    @media (max-width: 768px) {
      #container {
        padding: 28px 24px;
        min-width: auto;
        width: 85vw;
      }

      h1 {
        font-size: 1em;
      }

      button {
        width: 100%;
        margin: 6px 0;
      }
    }
  </style>
</head>
<body>
  <canvas id="visual"></canvas>
  <div id="container" ontouchstart="showUI()">
    <h1>∿ квантовая фрактальная музыка ∿</h1>
    <div>
      <button onclick="start()">коллапс</button>
      <button onclick="stop()">стабилизация</button>
      <button onclick="regenerate()">перерождение</button>
    </div>
    <div id="status">ожидание</div>
    <div id="info"></div>
  </div>
  <script>
    let generator = null;
    let audioUnlocked = false;

    window.__audioEnergy = 0.2;
    window.__visualEnergy = 0.0;

    const feedbackBuffer = new Uint8Array(4);

    function sampleVisualEnergy() {
      gl.readPixels(
        canvas.width / 2,
        canvas.height / 2,
        1,
        1,
        gl.RGBA,
        gl.UNSIGNED_BYTE,
        feedbackBuffer
      );

      const v =
        (feedbackBuffer[0] +
         feedbackBuffer[1] +
         feedbackBuffer[2]) / (3 * 255);

      window.__visualEnergy =
        window.__visualEnergy * 0.9 + v * 0.1;
    }
    
    let uiHidden = false;

    function hideUI() {
      const ui = document.getElementById('container');
      if (!ui) return;

      ui.style.transition = 'opacity 1.5s ease';
      ui.style.opacity = '0';
      ui.style.pointerEvents = 'none';
      uiHidden = true;
    }

    function showUI() {
      const ui = document.getElementById('container');
      if (!ui) return;

      ui.style.transition = 'opacity 0.6s ease';
      ui.style.opacity = '1';
      ui.style.pointerEvents = 'auto';
      uiHidden = false;
    }

    setTimeout(hideUI, 15000);

    // Визуализация
    const canvas = document.getElementById('visual');
    const gl = canvas.getContext('webgl');

    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    gl.viewport(0, 0, canvas.width, canvas.height);

    const vertexSrc = `
    attribute vec2 position;
    void main() {
      gl_Position = vec4(position, 0.0, 1.0);
    }`;

    const fragmentSrc = `
precision highp float;

uniform float time;
uniform float energy;
uniform vec2 resolution;

float hash(vec2 p){
  return fract(sin(dot(p,vec2(41.7,113.5)))*43758.5453);
}

vec2 attract(vec2 p, vec2 c, float s){
  vec2 d = c - p;
  float r = length(d)+0.001;
  return d / r * s / (r*r);
}

float noise(vec2 p){
  return hash(floor(p)) * 0.5 + hash(floor(p*2.0))*0.25;
}

void main(){

  vec2 uv = gl_FragCoord.xy / resolution.xy;
  vec2 p = uv*2.0-1.0;
  p.x *= resolution.x/resolution.y;

  float t = time*0.25;
  float e = clamp(energy,0.05,1.5);

  vec2 a1 = vec2(sin(t*0.7),cos(t*0.9))*0.6;
  vec2 a2 = vec2(cos(t*1.1),sin(t*0.6))*0.5;
  vec2 a3 = vec2(sin(t*0.4+2.0),cos(t*0.5))*0.7;

  vec2 v = vec2(0.0);

  v += attract(p,a1,0.8*e);
  v += attract(p,a2,0.6*e);
  v += attract(p,a3,0.7*e);

  v += vec2(
    noise(p*6.0+t),
    noise(p*6.0-t)
  )*0.15;

  p += v*0.25;

  float d1 = length(p-a1);
  float d2 = length(p-a2);
  float d3 = length(p-a3);

  float ink =
    exp(-d1*6.0)+
    exp(-d2*5.0)+
    exp(-d3*7.0);

  float grain = noise(p*12.0+t)*0.15;

  float paint = smoothstep(0.05,0.8,ink+grain);

  paint = pow(paint, 0.75);
  paint *= 0.9 + e*2.0;
  paint = clamp(paint * 1.8, 0.0, 1.0);

  gl_FragColor = vec4(vec3(paint),0.22);
}
`;

    function compile(type, src) {
      const s = gl.createShader(type);
      gl.shaderSource(s, src);
      gl.compileShader(s);
      return s;
    }

    const vs = compile(gl.VERTEX_SHADER, vertexSrc);
    const fs = compile(gl.FRAGMENT_SHADER, fragmentSrc);

    const program = gl.createProgram();
    gl.attachShader(program, vs);
    gl.attachShader(program, fs);
    gl.linkProgram(program);
    gl.useProgram(program);

    const buffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);

    gl.bufferData(
      gl.ARRAY_BUFFER,
      new Float32Array([
        -1, -1,
         1, -1,
        -1,  1,
         1,  1
      ]),
      gl.STATIC_DRAW
    );

    const pos = gl.getAttribLocation(program, 'position');
    gl.enableVertexAttribArray(pos);
    gl.vertexAttribPointer(pos, 2, gl.FLOAT, false, 0, 0);

    const uTime = gl.getUniformLocation(program, 'time');
    const uEnergy = gl.getUniformLocation(program, 'energy');
    const uRes = gl.getUniformLocation(program, 'resolution');

    function render(now) {
      const t = now * 0.001;
      const energy = window.__audioEnergy || 0.2;

      gl.uniform1f(uTime, t);
      gl.uniform1f(uEnergy, energy);
      gl.uniform2f(uRes, canvas.width, canvas.height);

      gl.enable(gl.BLEND);
      gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

      gl.clearColor(0.0,0.0,0.0,0.018);
      gl.clear(gl.COLOR_BUFFER_BIT);

      gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

      sampleVisualEnergy();

      requestAnimationFrame(render);
    }

    requestAnimationFrame(render);

    // Генератор музыки
    class QuantumNode {
      constructor(freq, depth, parent = null) {
        this.freq = freq;
        this.depth = depth;
        this.parent = parent;
        this.entangled = new Set();
        this.phase = Math.random() * Math.PI * 2;
        this.alive = true;
      }
      
      entangle(other) {
        this.entangled.add(other);
        other.entangled.add(this);
      }
      
      collapse() {
        const resonance = Math.sin(this.phase);
        this.entangled.forEach(node => {
          if (node.alive) {
            node.phase = this.phase + Math.PI * resonance;
          }
        });
        return resonance;
      }
    }

    class FractalMusicGenerator {
      constructor() {
        this.audioContext = null;
        this.nodes = [];
        this.baseFreq = 432;
        this.maxDepth = 5;
        this.isPlaying = false;
        this.time = 0;
        this.memory = [];
        this.maxMemory = 128;
        this.energy = 1.0;
        this.initQuantumField();
      }
      
      initQuantumField() {
        const root = new QuantumNode(this.baseFreq, 0);
        this.nodes.push(root);
        
        this.growFractal(root, 0);
        
        for (let i = 0; i < this.nodes.length; i++) {
          const node = this.nodes[i];
          const goldenRatio = 1.618033988749;
          const targetFreq = node.freq * Math.pow(goldenRatio, node.depth % 3);
          
          const partner = this.nodes.find(n => 
            Math.abs(n.freq - targetFreq) < 50 && n !== node
          );
          
          if (partner) {
            node.entangle(partner);
          }
        }
      }
      
      growFractal(parent, depth) {
        if (depth >= this.maxDepth) return;
        
        const ratios = [1.5, 1.333, 1.618, 2, 0.666];
        
        ratios.forEach((ratio, i) => {
          if (Math.random() > 0.3 || depth === 0) {
            const child = new QuantumNode(
              parent.freq * ratio,
              depth + 1,
              parent
            );
            this.nodes.push(child);
            
            if (Math.random() > 0.5) {
              parent.entangle(child);
            }
            
            this.growFractal(child, depth + 1);
          }
        });
      }
      
      createOscillator(freq, duration, startTime) {
        if (!this.audioContext) return;
        
        const osc = this.audioContext.createOscillator();
        const gain = this.audioContext.createGain();

        const ctx = this.audioContext;

        const visual = window.__visualEnergy || 0.0;

        const micro = (Math.random() - 0.5) * 15 * visual;
        const tempered = freq * Math.pow(2, micro / 1200);

        const waveforms = ['sine', 'triangle', 'sawtooth'];
        osc.type = waveforms[Math.floor(Math.random() * waveforms.length)];
        osc.frequency.value = tempered;

        const sub = ctx.createOscillator();
        sub.type = 'sine';
        sub.frequency.value = tempered * 0.5;

        const subGain = ctx.createGain();
        subGain.gain.value = 0.25 + visual * 0.2;

        const overtone = ctx.createOscillator();
        overtone.type = 'sine';
        overtone.frequency.value = tempered * (0.6 + visual * 0.5);

        const overtoneGain = ctx.createGain();
        overtoneGain.gain.value = 0.07 * (1.0 + visual);

        const noise = ctx.createBufferSource();
        const buffer = ctx.createBuffer(1, ctx.sampleRate * 0.3, ctx.sampleRate);
        const data = buffer.getChannelData(0);

        for (let i = 0; i < data.length; i++) {
          data[i] = (Math.random() * 2 - 1) * 0.15;
        }

        noise.buffer = buffer;
        noise.loop = true;

        const grainGain = ctx.createGain();
        grainGain.gain.value = 0.05 + visual * 0.08;

        const attack = 0.05 + Math.random() * 0.15;
        const decay = 0.2 + Math.random() * 0.4;
        const sustain = 0.25 + visual * 0.25;
        const release = 0.3 + Math.random() * 0.4;

        gain.gain.setValueAtTime(0, startTime);
        gain.gain.linearRampToValueAtTime(0.4, startTime + attack);
        gain.gain.linearRampToValueAtTime(
          sustain,
          startTime + attack + decay
        );
        gain.gain.setValueAtTime(
          sustain,
          startTime + duration - release
        );
        gain.gain.linearRampToValueAtTime(
          0,
          startTime + duration
        );

        osc.connect(gain);

        sub.connect(subGain);
        subGain.connect(gain);

        overtone.connect(overtoneGain);
        overtoneGain.connect(gain);

        noise.connect(grainGain);
        grainGain.connect(gain);

        const filter = ctx.createBiquadFilter();
        filter.type = 'lowpass';
        filter.frequency.setValueAtTime(800, startTime);
        filter.Q.value = 1.1;

        const delay = ctx.createDelay();
        delay.delayTime.value = 0.22 + Math.random() * 0.18;

        const tapeFeedback = ctx.createGain();
        tapeFeedback.gain.value = 0.45 + visual * 0.25;

        const tapeFilter = ctx.createBiquadFilter();
        tapeFilter.type = 'lowpass';
        tapeFilter.frequency.value = 1800;

        const verbDelay = ctx.createDelay();
        verbDelay.delayTime.value = 0.45 + Math.random() * 0.25;

        const verbFeedback = ctx.createGain();
        verbFeedback.gain.value = 0.6 + visual * 0.2;

        const wet = ctx.createGain();
        wet.gain.value = 0.45 + visual * 0.25;

        const dry = ctx.createGain();
        dry.gain.value = 0.65;

        gain.connect(filter);

        filter.connect(dry);
        dry.connect(ctx.destination);

        filter.connect(delay);
        delay.connect(tapeFilter);
        tapeFilter.connect(tapeFeedback);
        tapeFeedback.connect(delay);

        delay.connect(wet);

        wet.connect(verbDelay);
        verbDelay.connect(verbFeedback);
        verbFeedback.connect(verbDelay);

        verbDelay.connect(ctx.destination);

        osc.start(startTime);
        sub.start(startTime);
        overtone.start(startTime);
        noise.start(startTime);

        osc.stop(startTime + duration);
        sub.stop(startTime + duration);
        overtone.stop(startTime + duration);
        noise.stop(startTime + duration);
      }
      
      play() {
        if (this.isPlaying) return;

        // КРИТИЧНО: создаём AudioContext здесь
        if (!this.audioContext) {
          this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
        }

        // Разблокируем контекст
        if (this.audioContext.state === 'suspended') {
          this.audioContext.resume();
        }

        this.isPlaying = true;
        this.generate();
      }
      
      generate() {
        if (!this.isPlaying || !this.audioContext) return;

        const now = this.audioContext.currentTime;

        let activeNode;
        if (this.memory.length > 0 && Math.random() < 0.6) {
          activeNode = this.memory[Math.floor(Math.random() * this.memory.length)].node;
        } else {
          activeNode = this.nodes[Math.floor(Math.random() * this.nodes.length)];
        }

        if (!activeNode || !activeNode.alive) {
          setTimeout(() => this.generate(), 300);
          return;
        }

        const visual = window.__visualEnergy || 0.0;

        const resonance =
          activeNode.collapse() *
          (1.0 + visual * 1.8);

        const duration = 0.6 + Math.random() * 1.5;
        this.createOscillator(activeNode.freq, duration, now + 0.05);

        let localEnergy = Math.abs(resonance);

        activeNode.entangled.forEach(entangled => {
          if (entangled.alive && Math.random() > 0.3) {
            const harmonic = entangled.freq * (1 + resonance * 0.12);
            this.createOscillator(harmonic, duration * 0.75, now + 0.05);
            localEnergy += 0.5;
          }
        });

        this.memory.push({
          node: activeNode,
          energy: localEnergy,
          time: this.time
        });

        if (this.memory.length > this.maxMemory) {
          this.memory.shift();
        }

        this.energy = this.energy * 0.95 + localEnergy * 0.05;
        window.__audioEnergy =
          this.energy * (1.0 + window.__visualEnergy);

        const nextInterval =
          180 +
          Math.random() * 700 *
          (1.2 - Math.min(this.energy, 1));

        setTimeout(() => this.generate(), nextInterval);

        this.time += nextInterval;

        if (this.energy < 0.2 && Math.random() > 0.7) {
          this.mutate();
        } else if (Math.random() > 0.97) {
          this.mutate();
        }
      }
      
      mutate() {
        const aliveNodes = this.nodes.filter(n => n.alive);

        if (aliveNodes.length < 4) return;

        const victim = aliveNodes[Math.floor(Math.random() * aliveNodes.length)];
        victim.alive = false;

        let parent = aliveNodes[0];
        let bestEnergy = -1;

        this.memory.forEach(m => {
          if (m.energy > bestEnergy && m.node.alive) {
            bestEnergy = m.energy;
            parent = m.node;
          }
        });

        const child = new QuantumNode(
          parent.freq * (1 + (Math.random() - 0.5) * 0.3),
          parent.depth + 1,
          parent
        );

        this.nodes.push(child);

        const partner = aliveNodes.find(n =>
          n !== child && Math.random() > 0.4
        );

        if (partner) {
          child.entangle(partner);
        }
      }
      
      stop() {
        this.isPlaying = false;
      }
    }

    function init() {
      if (!generator) {
        generator = new FractalMusicGenerator();
      }
      generator.memory = [];
      generator.energy = 1.0;
      document.getElementById('status').textContent = 'система инициализирована';
      document.getElementById('info').textContent = `узлов в поле: ${generator.nodes.length}`;
    }

    // КЛЮЧЕВАЯ ФУНКЦИЯ для мобильных
    function start() {
      if (!generator) {
        init();
      }

      // Создаём AudioContext ВНУТРИ обработчика клика
      if (!generator.audioContext) {
        generator.audioContext = new (window.AudioContext || window.webkitAudioContext)();
      }

      generator.play();

      showUI();
      setTimeout(hideUI, 4000);

      document.getElementById('status').textContent = 'квантовый коллапс активен';
    }

    function stop() {
      if (generator) {
        generator.stop();
        document.getElementById('status').textContent = 'волновая функция стабилизирована';
      }
    }

    function regenerate() {
      if (generator) {
        generator.stop();
      }
      generator = null;
      init();
    }

    window.addEventListener('resize', () => {
      if (!canvas || !gl) return;

      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      gl.viewport(0, 0, canvas.width, canvas.height);
    });
</script>
</body>
</html>
